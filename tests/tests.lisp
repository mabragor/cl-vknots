
(in-package :cl-vknots-tests)

(cl-interpol:enable-interpol-syntax)

(def-suite cl-vknots)
(in-suite cl-vknots)

(test simple-loops
  (is (equal '(* (** (q "N") 1) "1") (decompose (deserialize-qed '((1))))))
  (is (equal '(* (** (q "N") 2) "1") (decompose (deserialize-qed '((1) (2))))))
  (is (equal '(* (** (q "N") 3) "1") (decompose (deserialize-qed '((1) (2) (3)))))))
      
(test simple-lines
  (is (equal '(* (Q "N-1") (* (** (Q "N") 1) "1")) (decompose (deserialize-qed '((1 1) (2 1))))))
  (is (equal '(* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1")))
	     (decompose (deserialize-qed '((1 1) (2 1 2) (3 2))))))
  (is (equal '(* (Q "N-1") (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
	     (decompose (deserialize-qed '((1 1) (2 1 2) (3 2 3) (4 3)))))))

(test 2-strand-diagrams
  (is (equal '(* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))
	     (decompose (deserialize-qed '((1 1 2) (2 1 2))))))
  (is (equal '(* (Q "2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
	     (decompose (deserialize-qed '((1 1 2 3) (2 1 2 3))))))
  (is (equal '(* (Q "2") (* (Q "2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))))
	     (decompose (deserialize-qed '((1 1 2 3 4) (2 1 2 3 4)))))))

(test torus
  (is (equal '(+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
		(* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
	     (decompose (deserialize-qed (torus-dessin 2 3)))))
  (is (equal '(+ (* (Q "N-2") (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
				  (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1")))))
		(* (Q "N-1") (* (Q "2") (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))
	     (decompose (deserialize-qed (torus-dessin 2 4)))))
  ;; (is (equal '(+ (* (Q "2") (* (Q "2") (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
  ;; 					  (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))
  ;; 	       (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
  ;; 		(* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
  ;; 	       (- (* (Q "2") (+ (* (Q "N-2") (* (Q "N-1") (* (** (Q "N") 1) "1")))
  ;; 				(* (** (Q "N") 1) (* (Q "N-1") (* (** (Q "N") 1) "1")))))))
  ;; 	     (decompose (deserialize-qed (torus-dessin 3 3)))))
  ;; (is (equal '(+ (* (Q "2") (* (Q "2") (+ (* (Q "2") (* (Q "2")
  ;; 							(+ (* (Q "2") (* (Q "2") (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))
  ;; 							   (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
  ;; 							   (- (* (Q "2") (+ (* (Q "N-2") (* (Q "N-1") (* (** (Q "N") 1) "1"))) (* (** (Q "N") 1) (* (Q "N-1") (* (** (Q "N") 1) "1")))))))))
  ;; 					  (+ (* (Q "2") (* (Q "2") (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))
  ;; 					     (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
  ;; 					     (- (* (Q "2") (+ (* (Q "N-2") (* (Q "N-1") (* (** (Q "N") 1) "1"))) (* (** (Q "N") 1) (* (Q "N-1") (* (** (Q "N") 1) "1")))))))
  ;; 					  (- (* (Q "2") (* (Q "2") (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))))))
  ;; 	       (+
  ;; 		(* (Q "2")
  ;; 		 (* (Q "2")
  ;; 		    (+
  ;; 		     (+ (* (Q "N-2") (* (Q "2") (* (Q "2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))
  ;; 			(+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (** (Q "N") 1) (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))
  ;; 		     (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
  ;; 		     (- (* (Q "2") (+ (* (Q "N-2") (* (Q "N-1") (* (** (Q "N") 1) "1"))) (* (** (Q "N") 1) (* (Q "N-1") (* (** (Q "N") 1) "1")))))))))
  ;; 		(+ (* (Q "2") (* (Q "2") (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))
  ;; 		 (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
  ;; 		 (- (* (Q "2") (+ (* (Q "N-2") (* (Q "N-1") (* (** (Q "N") 1) "1"))) (* (** (Q "N") 1) (* (Q "N-1") (* (** (Q "N") 1) "1")))))))
  ;; 		(- (* (Q "2") (* (Q "2") (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))))
  ;; 	       (-
  ;; 		(* (Q "2")
  ;; 		 (* (Q "2")
  ;; 		    (+
  ;; 		     (+ (* (Q "N-2") (* (Q "2") (* (Q "2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))
  ;; 			(+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (** (Q "N") 1) (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1"))))))
  ;; 		     (+ (* (Q "N-2") (* (Q "2") (* (Q "N-1") (* (** (Q "N") 1) "1")))) (* (Q "N-1") (* (Q "N-1") (* (** (Q "N") 1) "1"))))
  ;; 		     (- (* (Q "2") (+ (* (Q "N-2") (* (Q "N-1") (* (** (Q "N") 1) "1"))) (* (** (Q "N") 1) (* (Q "N-1") (* (** (Q "N") 1) "1")))))))))))
  ;; 	     (decompose (deserialize-qed (torus-dessin 5 3))))))
  )

(test virtuals
  (is (equal '(* (- (Q "N-1")) (* (** (Q "N") 1) "1"))
	     (decompose (deserialize-qed '((1 1 1))))))
  (is (equal '(* (- (Q "N-1")) (* (- (Q "N-1")) (* (** (Q "N") 1) "1")))
	     (decompose (deserialize-qed '((1 1 1 2 2))))))
  (is (equal '(* (Q "2") (* (- (Q "N-1")) (* (** (Q "N") 1) "1")))
	     (decompose (deserialize-qed '((1 1 2 1 2))))))
  (is (equal '(* (Q "2") (* (- (Q "N-1")) (* (Q "2") (* (- (Q "N-1")) (* (** (Q "N") 1) "1")))))
	     (decompose (deserialize-qed '((1 1 2 1 2 3 4 3 4)))))))

(test deserialize-serialize-loops
  (macrolet ((frob (x &optional y)
	       `(is (equal ',x (serialize-qed (deserialize-qed ',(or y x)))))))
    (frob ((1)))
    (frob ((1) (2)))
    (frob ((1) (2) (3)))
    (frob ((1 1) (2 1)))
    (frob ((1 1 2) (2 1 2)))
    (frob ((1 1 2) (2 2 1)))
    (frob ((1 1 2) (2 2 1)) ((1 2 1) (2 1 2)))
    ;; KLUDGE: we should better test properly for correct cyclic order of vertices,
    ;; then fine-tuning the answer to particular implementation of hashing functions etc.
    (frob ((1 1 2) (2 1 3 2 4) (3 4 3)) ((1 1 2) (2 1 3 2 4) (3 3 4)))
    (frob ((1 1 2 3) (2 1 4 2 5 3 6) (3 6 4 5)) ((1 1 2 3) (2 1 4 2 5 3 6) (3 4 5 6)))))
  
(test cabling
  (is (equal '((n a b c d)) (bud-vertex '(n a b c d) 1)))
  (is (equal '((n (a 1) (:a 1 0) (c 1) (:a 0 1))
	       (n (a 2) (b 1) (:a 1 0) (:a 2 1))
	       (n (:a 2 1) (b 2) (:a 1 2) (d 2))
	       (n (:a 0 1) (:a 1 2) (c 2) (d 1)))
	     (bud-vertex '(n a b c d) 2 :a)))
  (is (equal '((n (a 1) (:a 1 0) (c 1) (:a 0 1))
	       (n (a 3) (b 1) (:a 3 0) (:a 4 1))
	       (n (:a 4 3) (b 3) (:a 3 4) (d 3))
	       (n (:a 0 3) (:a 1 4) (c 3) (d 1))
	       (n (a 2) (:a 3 0) (:a 1 0) (:a 2 1))
	       (n (:a 0 1) (:a 1 2) (c 2) (:a 0 3))
	       (n (:a 4 1) (b 2) (:a 3 2) (:a 4 3))
	       (n (:a 2 3) (:a 3 4) (:a 1 4) (d 2))
	       (n (:a 2 1) (:a 3 2) (:a 1 2) (:a 2 3)))
	     (bud-vertex '(n a b c d) 3 :a)))
  (is (equal '((n (a 1) (:a 1 0) (c 1) (:a 0 1))
	       (n (a 4) (b 1) (:a 5 0) (:a 6 1))
	       (n (:a 6 5) (b 4) (:a 5 6) (d 4))
	       (n (:a 0 5) (:a 1 6) (c 4) (d 1))
	       (n (a 2) (:a 3 0) (:a 1 0) (:a 2 1))
	       (n (a 3) (:a 5 0) (:a 3 0) (:a 4 1))
	       (n (:a 0 1) (:a 1 2) (c 2) (:a 0 3))
	       (n (:a 0 3) (:a 1 4) (c 3) (:a 0 5))
	       (n (:a 6 1) (b 2) (:a 5 2) (:a 6 3))
	       (n (:a 6 3) (b 3) (:a 5 4) (:a 6 5))
	       (n (:a 2 5) (:a 3 6) (:a 1 6) (d 2))
	       (n (:a 4 5) (:a 5 6) (:a 3 6) (d 3))
	       (n (:a 2 1) (:a 3 2) (:a 1 2) (:a 2 3))
	       (n (:a 2 3) (:a 3 4) (:a 1 4) (:a 2 5))
	       (n (:a 4 1) (:a 5 2) (:a 3 2) (:a 4 3))
	       (n (:a 4 3) (:a 5 4) (:a 3 4) (:a 4 5)))
	     (bud-vertex '(n a b c d) 4 :a))))
  

(test lousy-simplify-dessin
  (macrolet ((frob (n-factors n-1-factors 2-factors min-one-factors x)
	       `(multiple-value-bind (x1 x2 x3 x4) (lousy-simplify-dessin (deserialize2 ',x))
		  (is (equal (list ,n-factors ,n-1-factors ,2-factors ,min-one-factors)
			     (list x1 x2 x3 x4))))))
    (frob 1 0 0 0 ((1)))
    (frob 2 0 0 0 ((1) (2)))
    (frob 1 1 0 0 ((1 1) (2 1)))
    (frob 1 1 1 0 ((1 1 2) (2 1 2)))
    (frob 1 1 2 0 ((1 1 2 3) (2 1 2 3)))
    (frob 1 1 0 1 ((1 1 1)))
    (frob 1 2 0 2 ((1 1 1 2 2)))
    (frob 1 2 1 2 ((1 1 1 2 3 2 3)))))
    

(test homfly-serial-toolchain-simple
  (macrolet ((frob (&rest clauses)
	       `(is (equal ',(make-list (length clauses) :initial-element "1")
			   (compare-q-exprs (list ,@(mapcar (lambda (clause)
							      `(list ,(car clause)
								     (homfly-serial-toolchain ,(cadr clause))))
							    clauses)))))))
    (frob ("q[N]" '((1)))
	  ("q[N]^2" '((1) (2)))
	  ("q[N]^3" '((1) (2) (3)))
	  ("q[N]" '((1 1) (2 1)))
	  ("q[N]" '((1 (:w 1)) (2 1)))
	  ("q[N]" '((1 1) (2 1 2) (3 2)))
	  ("q[N]" '((1 (:w 1)) (2 1 2) (3 2)))
	  ("q[N]" '((1 1) (2 1 (:w 2)) (3 2)))
	  ("q[N]" '((1 (:w 1)) (2 1 (:w 2)) (3 2)))
	  ("q[N]^2" '((1 1 (:w 2)) (2 1 2)))
	  ("q[N]" '((1 1) (2 1 2) (3 2 3) (4 3)))
	  ("q[N]" '((1 1) (2 1 2) (3 2 3) (4 3 4) (5 4)))
	  ("q[N]" '((1 1 (:w 2) 3) (2 1 2 3)))
	  ("q[N]" '((1 1 2) (2 1 (:w 3) 2 4) (3 3 4)))
	  ("q[N]" (torus-dessin 1 7))
	  ("q[N]" (torus-dessin 1 8)))))


(test decompose-vs-lousy-decompose
  (macrolet ((frob (x)
	       `(over-all-subdessins (deserialize2 ,x)
		  (lambda (dessin charge)
		    (declare (ignore charge))
		    (let ((it (serialize2 dessin)))
		      ;; (format t "Testing ~a~%" it)
		      (let ((lousy-expr (mathematica-serialize (lousy-decompose (deserialize2 it))))
			    (decompose-expr (mathematica-serialize (decompose (deserialize-qed it))))
			    (old-expr (with-output-to-string (stream)
					(print-dessin-poly stream
							   (n-dessin-recursion (deserialize2 it))))))
			(is (equal '("0" "0") (compare-q-exprs-minus `((,old-expr ,decompose-expr)
								       (,decompose-expr ,lousy-expr)))))))))))
    (frob '((1 1 (:w 2)) (2 1 3 2 4) (3 3 5 4 (:w 6)) (4 5 6)))))


(test homfly-serial-toolchain-complex
  (macrolet ((frob (&rest clauses)
	       `(is (equal ',(make-list (length clauses) :initial-element "1")
			   (compare-q-exprs (list ,@(mapcar (lambda (clause)
							      `(list ,(car clause)
								     (homfly-serial-toolchain ,(cadr clause))))
							    clauses)))))))
    (frob ("q[N]^2" '((1 1 (:w 2)) (2 1 3 2 4) (3 3 5 4 (:w 6)) (4 5 6))))
    (frob ("q[N]^2" '((1 1 (:w 2) 3 (:w 4)) (2 1 2 3 4))))
    (frob ("q[N]^3" '((1 1 (:w 2) (:w 3)) (2 1 4 2 (:w 5) 3 6) (3 4 5 6))))
    (frob ("q[N]" '((1 1 2 (:w 3) 4 (:w 5)) (2 1 2 3 4 5))))
    (frob ("q[N]" '((1 1 (:w 2)) (2 1 3 2 (:w 4)) (3 3 (:w 5) 4 6) (4 5 (:w 7) 6 8) (5 7 8))))
    (frob ("q[N]" '((1 (:w 1) (:w 2) 3 4) (2 1 (:w 5) 2 (:w 6) 3 7 4 8) (3 5 6 7 8))))
    (frob ("q[N]" '((1 1 (:w 2) (:w 3))
		    (2 1 4 2 (:w 5) 3 6)
		    (3 4 7 5 (:w 8) 6 (:w 9))
		    (4 7 8 9))))
    ))

(test rolfsen-homflies
  (labels ((frob (n)
	     (let ((total-num (cdr (assoc n *rolfsen-total-numbers*))))
	       (let ((results (compare-homfly-with-katlas
			       (iter (for i from 1 to total-num)
				     (collect #?"Knot[$(n), $(i)]")))))
		 (let ((n (length results))
		       (covered 0)
		       (noncovered nil))
		   (iter (for i from 1)
			 (for res in results)
			 (cond ((equal "1" res) (incf covered) (is (equal t t)))
			       ((cl-ppcre:all-matches "HordeDiag" res) (push i noncovered) (is (equal t t)))
			       (t (is (equal t nil)))))
		   (format t "~%Coverage: ~a/~a (~{~a~^ ~})~%" covered n noncovered))))))
    (frob 3) (frob 4) (frob 5) (frob 6) (frob 7) (frob 8) (frob 9) (frob 10)
    ))

(test rolfsen-actual-homflies
  (labels ((frob (n)
	     (let ((total-num (cdr (assoc n *rolfsen-total-numbers*))))
	       (let ((results (compare-actual-homfly-with-katlas
			       (iter (for i from 1 to total-num)
				     (collect #?"Knot[$(n), $(i)]")))))
		 (iter (for i from 1)
		       (for res in results)
		       (is (or (equal "1" res)
			       (cl-ppcre:all-matches "HordeDiag" res))))))))
    (frob 3) (frob 4)
    (frob 5) (frob 6) (frob 7) (frob 8) (frob 9) (frob 10)
    ))


